{"version":3,"sources":["../../../src/plugins/stub/websocket.js"],"names":["PLUGIN_NAME","module","exports","opts","app","handlerParser","server","require","createServer","io","set","on","socket","console","log","id","data","broadcast","emit","route","result","stubList","getHandlerListByPlugin","forEach","stubItem","SOCKET_ROUTE","params","Date","now","disable","emitEventName","eventName","_disable","getHandleModuleResult","then","catch","err"],"mappings":";;AAAA,IAAMA,cAAc,MAApB;;AAEAC,OAAOC,OAAP,GAAiB,UAAUC,IAAV,EAAgBC,GAAhB,EAAqBC,aAArB,EAAoC;AACnD,MAAMC,SAASC,QAAQ,MAAR,EAAgBC,YAAhB,CAA6BJ,GAA7B,CAAf;AACA,MAAMK,KAAKF,QAAQ,WAAR,EAAqBD,MAArB,CAAX;;AAEA;AACAG,KAAGC,GAAH,CAAO,SAAP,EAAkB,KAAlB;;AAEAD,KAAGE,EAAH,CAAM,YAAN,EAAoB,UAAUC,MAAV,EAAkB;AACpCC,YAAQC,GAAR,CAAY,gBAAgBF,OAAOG,EAAnC;;AAEA;AACAH,WAAOD,EAAP,CAAU,UAAV,EAAsB,UAAUK,IAAV,EAAgB;AACpC;AACA;AACA;AACA;AACAJ,aAAOK,SAAP,CAAiBC,IAAjB,CAAsBF,KAAKG,KAA3B,EAAkCH,KAAKI,MAAvC;AACAR,aAAOM,IAAP,CAAYF,KAAKG,KAAjB,EAAwBH,KAAKI,MAA7B;AACD,KAPD;;AASA,QAAIC,WAAWhB,cAAciB,sBAAd,CAAqCtB,WAArC,CAAf;AACA;;AAEAqB,aAASE,OAAT,CAAiB,UAACC,QAAD,EAAc;AAC7B,UAAMC,eAAeD,SAASL,KAA9B;AACA;;AAEA;AACA;AACAP,aAAOD,EAAP,CAAUc,YAAV,EAAwB,UAAUC,MAAV,EAA6B;AAAA,YAAXvB,IAAW,uEAAJ,EAAI;;AACnDU,gBAAQC,GAAR,CAAYa,KAAKC,GAAL,EAAZ,EAAwBJ,SAASK,OAAjC,EAA0CJ,YAA1C,EAAwDb,OAAOG,EAA/D,EAAmEW,MAAnE,EAA2EvB,IAA3E;;AAEA;AACA,YAAI2B,gBAAgB3B,KAAK4B,SAAL,IAAkBN,YAAtC;;AAEA;AACA,YAAID,SAASK,OAAb,EAAsB;AACpBjB,iBAAOM,IAAP,CAAYY,aAAZ,EAA2B,EAAEE,UAAU,IAAZ,EAA3B;AACA;AACD;;AAED;AACA3B,sBAAc4B,qBAAd,CAAoCR,YAApC,EAAkDC,MAAlD,EACGQ,IADH,CACQ,UAACd,MAAD,EAAY;AAChBR,iBAAOM,IAAP,CAAYY,aAAZ,EAA2BV,MAA3B;AACD,SAHH,EAIGe,KAJH,CAIS,UAACC,GAAD,EAAS;AACdxB,iBAAOM,IAAP,CAAY,YAAZ,EAA0BkB,GAA1B;AACD,SANH;AAOD,OApBD;AAqBD,KA3BD;;AA6BA;AACAxB,WAAOD,EAAP,CAAU,YAAV,EAAwB,YAAY;AAClCE,cAAQC,GAAR,CAAY,gBAAgBF,OAAOG,EAAnC;AACD,KAFD;AAGD,GAjDD;;AAmDA,SAAOT,MAAP;AACD,CA3DD","file":"websocket.js","sourcesContent":["const PLUGIN_NAME = 'stub';\n\nmodule.exports = function (opts, app, handlerParser) {\n  const server = require('http').createServer(app);\n  const io = require('socket.io')(server);\n\n  // io.set('transports', ['websocket', 'xhr-polling', 'jsonp-polling', 'htmlfile', 'flashsocket']);\n  io.set('origins', '*:*');\n\n  io.on('connection', function (socket) {\n    console.log('connection ' + socket.id);\n\n    // 监听 emitStub，传递特殊的值，然后再将指定的数据发送给客户端的特定事件\n    socket.on('emitStub', function (data) {\n      // broadcast.emit 会广播给其他连接了 websocket 的用户，但是不会广播给自己\n      // 因此需要额外的 emit 发给自己以便校验\n      // 必须要一次 broadcast.emit，因为我们是在 matman 系统进行操作然后广播给其他服务的\n      // 必须要一次 emit，因为要进行校验\n      socket.broadcast.emit(data.route, data.result);\n      socket.emit(data.route, data.result);\n    });\n\n    let stubList = handlerParser.getHandlerListByPlugin(PLUGIN_NAME);\n    // console.log('--stubList--', stubList);\n\n    stubList.forEach((stubItem) => {\n      const SOCKET_ROUTE = stubItem.route;\n      // console.log('==========SOCKET_ROUTE===========', SOCKET_ROUTE);\n\n      // 每一个 stub 都监听其特定的消息\n      // TODO 此处需要确认如果有多个同样的 SOCKET_ROUTE，则会发生什么事情，是否需要程序进行提示？\n      socket.on(SOCKET_ROUTE, function (params, opts = {}) {\n        console.log(Date.now(), stubItem.disable, SOCKET_ROUTE, socket.id, params, opts);\n\n        // websocket 名字可以通过传递参数来指定回调结果\n        let emitEventName = opts.eventName || SOCKET_ROUTE;\n\n        // 如果该项打桩为 disable，则不做任何处理\n        if (stubItem.disable) {\n          socket.emit(emitEventName, { _disable: true });\n          return;\n        }\n\n        // TODO 此处应该可以支持任意的参数\n        handlerParser.getHandleModuleResult(SOCKET_ROUTE, params)\n          .then((result) => {\n            socket.emit(emitEventName, result);\n          })\n          .catch((err) => {\n            socket.emit('stub_error', err);\n          });\n      });\n    });\n\n    // when the user disconnects.. perform this\n    socket.on('disconnect', function () {\n      console.log('disconnect ' + socket.id);\n    });\n  });\n\n  return server;\n};\n"]}