{"version":3,"sources":["../../../src/plugins/stub/websocket.js"],"names":["PLUGIN_NAME","module","exports","opts","app","handlerParser","server","require","createServer","io","on","socket","console","log","id","data","broadcast","emit","route","result","stubList","getHandlerListByPlugin","forEach","stubItem","SOCKET_ROUTE","params","Date","now","disable","getHandleModuleResult","then","eventName","catch","err"],"mappings":";;AAAA,IAAMA,cAAc,MAApB;;AAEAC,OAAOC,OAAP,GAAiB,UAAUC,IAAV,EAAgBC,GAAhB,EAAqBC,aAArB,EAAoC;AACnD,MAAMC,SAASC,QAAQ,MAAR,EAAgBC,YAAhB,CAA6BJ,GAA7B,CAAf;AACA,MAAMK,KAAKF,QAAQ,WAAR,EAAqBD,MAArB,CAAX;;AAEAG,KAAGC,EAAH,CAAM,YAAN,EAAoB,UAAUC,MAAV,EAAkB;AACpCC,YAAQC,GAAR,CAAY,gBAAgBF,OAAOG,EAAnC;;AAEAH,WAAOD,EAAP,CAAU,UAAV,EAAsB,UAAUK,IAAV,EAAgB;AACpC;AACA;AACA;AACA;AACAJ,aAAOK,SAAP,CAAiBC,IAAjB,CAAsBF,KAAKG,KAA3B,EAAkCH,KAAKI,MAAvC;AACAR,aAAOM,IAAP,CAAYF,KAAKG,KAAjB,EAAwBH,KAAKI,MAA7B;AACD,KAPD;;AASA,QAAIC,WAAWf,cAAcgB,sBAAd,CAAqCrB,WAArC,CAAf;AACA;;AAEAoB,aAASE,OAAT,CAAiB,UAACC,QAAD,EAAc;AAC7B,UAAMC,eAAeD,SAASL,KAA9B;AACA;;AAEA;AACA;AACAP,aAAOD,EAAP,CAAUc,YAAV,EAAwB,UAAUC,MAAV,EAA6B;AAAA,YAAXtB,IAAW,uEAAJ,EAAI;;AACnDS,gBAAQC,GAAR,CAAYa,KAAKC,GAAL,EAAZ,EAAwBJ,SAASK,OAAjC,EAA0CJ,YAA1C,EAAwDb,OAAOG,EAA/D,EAAmEW,MAAnE,EAA2EtB,IAA3E;;AAEA;AACA,YAAIoB,SAASK,OAAb,EAAsB;AACpB;AACD;;AAED;AACAvB,sBAAcwB,qBAAd,CAAoCL,YAApC,EAAkDC,MAAlD,EACGK,IADH,CACQ,UAACX,MAAD,EAAY;AAChBR,iBAAOM,IAAP,CAAYd,KAAK4B,SAAL,IAAkBP,YAA9B,EAA4CL,MAA5C;AACD,SAHH,EAIGa,KAJH,CAIS,UAACC,GAAD,EAAS;AACdtB,iBAAOM,IAAP,CAAY,YAAZ,EAA0BgB,GAA1B;AACD,SANH;AAOD,OAhBD;AAiBD,KAvBD;;AAyBA;AACAtB,WAAOD,EAAP,CAAU,YAAV,EAAwB,YAAY;AAClCE,cAAQC,GAAR,CAAY,gBAAgBF,OAAOG,EAAnC;AACD,KAFD;AAGD,GA5CD;;AA8CA,SAAOR,MAAP;AACD,CAnDD","file":"websocket.js","sourcesContent":["const PLUGIN_NAME = 'stub';\n\nmodule.exports = function (opts, app, handlerParser) {\n  const server = require('http').createServer(app);\n  const io = require('socket.io')(server);\n\n  io.on('connection', function (socket) {\n    console.log('connection ' + socket.id);\n\n    socket.on('emitStub', function (data) {\n      // broadcast.emit 会广播给其他连接了 websocket 的用户，但是不会广播给自己\n      // 因此需要额外的 emit 发给自己以便校验\n      // 必须要一次 broadcast.emit，因为我们是在 matman 系统进行操作然后广播给其他服务的\n      // 必须要一次 emit，因为要进行校验\n      socket.broadcast.emit(data.route, data.result);\n      socket.emit(data.route, data.result);\n    });\n\n    let stubList = handlerParser.getHandlerListByPlugin(PLUGIN_NAME);\n    // console.log('--stubList--', stubList);\n\n    stubList.forEach((stubItem) => {\n      const SOCKET_ROUTE = stubItem.route;\n      // console.log('==========SOCKET_ROUTE===========', SOCKET_ROUTE);\n\n      // 每一个 stub 都监听其特定的消息\n      // TODO 此处需要确认如果有多个同样的 SOCKET_ROUTE，则会发生什么事情，是否需要程序进行提示？\n      socket.on(SOCKET_ROUTE, function (params, opts = {}) {\n        console.log(Date.now(), stubItem.disable, SOCKET_ROUTE, socket.id, params, opts);\n\n        // 如果该项打桩为 disable，则不做任何处理\n        if (stubItem.disable) {\n          return;\n        }\n\n        // TODO 此处应该可以支持任意的参数\n        handlerParser.getHandleModuleResult(SOCKET_ROUTE, params)\n          .then((result) => {\n            socket.emit(opts.eventName || SOCKET_ROUTE, result);\n          })\n          .catch((err) => {\n            socket.emit('stub_error', err);\n          });\n      });\n    });\n\n    // when the user disconnects.. perform this\n    socket.on('disconnect', function () {\n      console.log('disconnect ' + socket.id);\n    });\n  });\n\n  return server;\n};\n"]}